// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CarMessages.proto

#ifndef PROTOBUF_CarMessages_2eproto__INCLUDED
#define PROTOBUF_CarMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CarMessages_2eproto();
void protobuf_AssignDesc_CarMessages_2eproto();
void protobuf_ShutdownFile_CarMessages_2eproto();

class Imu_Accel_Gyro;
class CommandMsg;
class CommandReply;
class msg_Matrix;
class msg_ControlCommand;
class msg_VehicleState;
class msg_MotionSample;
class msg_Segments;
class msg_ControlPlan;
class msg_ImuLog;
class msg_LocalizerLog;
class msg_Log;

// ===================================================================

class Imu_Accel_Gyro : public ::google::protobuf::Message {
 public:
  Imu_Accel_Gyro();
  virtual ~Imu_Accel_Gyro();

  Imu_Accel_Gyro(const Imu_Accel_Gyro& from);

  inline Imu_Accel_Gyro& operator=(const Imu_Accel_Gyro& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imu_Accel_Gyro& default_instance();

  void Swap(Imu_Accel_Gyro* other);

  // implements Message ----------------------------------------------

  Imu_Accel_Gyro* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imu_Accel_Gyro& from);
  void MergeFrom(const Imu_Accel_Gyro& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double AccelX = 1;
  inline bool has_accelx() const;
  inline void clear_accelx();
  static const int kAccelXFieldNumber = 1;
  inline double accelx() const;
  inline void set_accelx(double value);

  // required double AccelY = 2;
  inline bool has_accely() const;
  inline void clear_accely();
  static const int kAccelYFieldNumber = 2;
  inline double accely() const;
  inline void set_accely(double value);

  // required double AccelZ = 3;
  inline bool has_accelz() const;
  inline void clear_accelz();
  static const int kAccelZFieldNumber = 3;
  inline double accelz() const;
  inline void set_accelz(double value);

  // required double GyroX = 4;
  inline bool has_gyrox() const;
  inline void clear_gyrox();
  static const int kGyroXFieldNumber = 4;
  inline double gyrox() const;
  inline void set_gyrox(double value);

  // required double GyroY = 5;
  inline bool has_gyroy() const;
  inline void clear_gyroy();
  static const int kGyroYFieldNumber = 5;
  inline double gyroy() const;
  inline void set_gyroy(double value);

  // required double GyroZ = 6;
  inline bool has_gyroz() const;
  inline void clear_gyroz();
  static const int kGyroZFieldNumber = 6;
  inline double gyroz() const;
  inline void set_gyroz(double value);

  // required int32 timer = 7;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 7;
  inline ::google::protobuf::int32 timer() const;
  inline void set_timer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Imu_Accel_Gyro)
 private:
  inline void set_has_accelx();
  inline void clear_has_accelx();
  inline void set_has_accely();
  inline void clear_has_accely();
  inline void set_has_accelz();
  inline void clear_has_accelz();
  inline void set_has_gyrox();
  inline void clear_has_gyrox();
  inline void set_has_gyroy();
  inline void clear_has_gyroy();
  inline void set_has_gyroz();
  inline void clear_has_gyroz();
  inline void set_has_timer();
  inline void clear_has_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double accelx_;
  double accely_;
  double accelz_;
  double gyrox_;
  double gyroy_;
  double gyroz_;
  ::google::protobuf::int32 timer_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static Imu_Accel_Gyro* default_instance_;
};
// -------------------------------------------------------------------

class CommandMsg : public ::google::protobuf::Message {
 public:
  CommandMsg();
  virtual ~CommandMsg();

  CommandMsg(const CommandMsg& from);

  inline CommandMsg& operator=(const CommandMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMsg& default_instance();

  void Swap(CommandMsg* other);

  // implements Message ----------------------------------------------

  CommandMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMsg& from);
  void MergeFrom(const CommandMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Accel = 1;
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 1;
  inline double accel() const;
  inline void set_accel(double value);

  // required double Phi = 2;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 2;
  inline double phi() const;
  inline void set_phi(double value);

  // @@protoc_insertion_point(class_scope:CommandMsg)
 private:
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_phi();
  inline void clear_has_phi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double accel_;
  double phi_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static CommandMsg* default_instance_;
};
// -------------------------------------------------------------------

class CommandReply : public ::google::protobuf::Message {
 public:
  CommandReply();
  virtual ~CommandReply();

  CommandReply(const CommandReply& from);

  inline CommandReply& operator=(const CommandReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReply& default_instance();

  void Swap(CommandReply* other);

  // implements Message ----------------------------------------------

  CommandReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReply& from);
  void MergeFrom(const CommandReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CommandReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static CommandReply* default_instance_;
};
// -------------------------------------------------------------------

class msg_Matrix : public ::google::protobuf::Message {
 public:
  msg_Matrix();
  virtual ~msg_Matrix();

  msg_Matrix(const msg_Matrix& from);

  inline msg_Matrix& operator=(const msg_Matrix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_Matrix& default_instance();

  void Swap(msg_Matrix* other);

  // implements Message ----------------------------------------------

  msg_Matrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_Matrix& from);
  void MergeFrom(const msg_Matrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rows = 1;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // required uint32 cols = 2;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 2;
  inline ::google::protobuf::uint32 cols() const;
  inline void set_cols(::google::protobuf::uint32 value);

  // repeated double data = 3 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline double data(int index) const;
  inline void set_data(int index, double value);
  inline void add_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:msg_Matrix)
 private:
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 cols_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_Matrix* default_instance_;
};
// -------------------------------------------------------------------

class msg_ControlCommand : public ::google::protobuf::Message {
 public:
  msg_ControlCommand();
  virtual ~msg_ControlCommand();

  msg_ControlCommand(const msg_ControlCommand& from);

  inline msg_ControlCommand& operator=(const msg_ControlCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_ControlCommand& default_instance();

  void Swap(msg_ControlCommand* other);

  // implements Message ----------------------------------------------

  msg_ControlCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_ControlCommand& from);
  void MergeFrom(const msg_ControlCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double force = 1;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 1;
  inline double force() const;
  inline void set_force(double value);

  // required double phi = 2;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 2;
  inline double phi() const;
  inline void set_phi(double value);

  // required double curvature = 3;
  inline bool has_curvature() const;
  inline void clear_curvature();
  static const int kCurvatureFieldNumber = 3;
  inline double curvature() const;
  inline void set_curvature(double value);

  // required double dt = 4;
  inline bool has_dt() const;
  inline void clear_dt();
  static const int kDtFieldNumber = 4;
  inline double dt() const;
  inline void set_dt(double value);

  // required double time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline double time() const;
  inline void set_time(double value);

  // required .msg_Matrix torque_3d = 6;
  inline bool has_torque_3d() const;
  inline void clear_torque_3d();
  static const int kTorque3DFieldNumber = 6;
  inline const ::msg_Matrix& torque_3d() const;
  inline ::msg_Matrix* mutable_torque_3d();
  inline ::msg_Matrix* release_torque_3d();
  inline void set_allocated_torque_3d(::msg_Matrix* torque_3d);

  // @@protoc_insertion_point(class_scope:msg_ControlCommand)
 private:
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_curvature();
  inline void clear_has_curvature();
  inline void set_has_dt();
  inline void clear_has_dt();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_torque_3d();
  inline void clear_has_torque_3d();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double force_;
  double phi_;
  double curvature_;
  double dt_;
  double time_;
  ::msg_Matrix* torque_3d_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_ControlCommand* default_instance_;
};
// -------------------------------------------------------------------

class msg_VehicleState : public ::google::protobuf::Message {
 public:
  msg_VehicleState();
  virtual ~msg_VehicleState();

  msg_VehicleState(const msg_VehicleState& from);

  inline msg_VehicleState& operator=(const msg_VehicleState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_VehicleState& default_instance();

  void Swap(msg_VehicleState* other);

  // implements Message ----------------------------------------------

  msg_VehicleState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_VehicleState& from);
  void MergeFrom(const msg_VehicleState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .msg_Matrix pose_7d = 1;
  inline bool has_pose_7d() const;
  inline void clear_pose_7d();
  static const int kPose7DFieldNumber = 1;
  inline const ::msg_Matrix& pose_7d() const;
  inline ::msg_Matrix* mutable_pose_7d();
  inline ::msg_Matrix* release_pose_7d();
  inline void set_allocated_pose_7d(::msg_Matrix* pose_7d);

  // required .msg_Matrix vel_3d = 2;
  inline bool has_vel_3d() const;
  inline void clear_vel_3d();
  static const int kVel3DFieldNumber = 2;
  inline const ::msg_Matrix& vel_3d() const;
  inline ::msg_Matrix* mutable_vel_3d();
  inline ::msg_Matrix* release_vel_3d();
  inline void set_allocated_vel_3d(::msg_Matrix* vel_3d);

  // required .msg_Matrix w_3d = 3;
  inline bool has_w_3d() const;
  inline void clear_w_3d();
  static const int kW3DFieldNumber = 3;
  inline const ::msg_Matrix& w_3d() const;
  inline ::msg_Matrix* mutable_w_3d();
  inline ::msg_Matrix* release_w_3d();
  inline void set_allocated_w_3d(::msg_Matrix* w_3d);

  // required double curvature = 4;
  inline bool has_curvature() const;
  inline void clear_curvature();
  static const int kCurvatureFieldNumber = 4;
  inline double curvature() const;
  inline void set_curvature(double value);

  // required double steering = 5;
  inline bool has_steering() const;
  inline void clear_steering();
  static const int kSteeringFieldNumber = 5;
  inline double steering() const;
  inline void set_steering(double value);

  // required double time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline double time() const;
  inline void set_time(double value);

  // required int32 source = 7;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 7;
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg_VehicleState)
 private:
  inline void set_has_pose_7d();
  inline void clear_has_pose_7d();
  inline void set_has_vel_3d();
  inline void clear_has_vel_3d();
  inline void set_has_w_3d();
  inline void clear_has_w_3d();
  inline void set_has_curvature();
  inline void clear_has_curvature();
  inline void set_has_steering();
  inline void clear_has_steering();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::msg_Matrix* pose_7d_;
  ::msg_Matrix* vel_3d_;
  ::msg_Matrix* w_3d_;
  double curvature_;
  double steering_;
  double time_;
  ::google::protobuf::int32 source_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_VehicleState* default_instance_;
};
// -------------------------------------------------------------------

class msg_MotionSample : public ::google::protobuf::Message {
 public:
  msg_MotionSample();
  virtual ~msg_MotionSample();

  msg_MotionSample(const msg_MotionSample& from);

  inline msg_MotionSample& operator=(const msg_MotionSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_MotionSample& default_instance();

  void Swap(msg_MotionSample* other);

  // implements Message ----------------------------------------------

  msg_MotionSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_MotionSample& from);
  void MergeFrom(const msg_MotionSample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg_VehicleState states = 1;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 1;
  inline const ::msg_VehicleState& states(int index) const;
  inline ::msg_VehicleState* mutable_states(int index);
  inline ::msg_VehicleState* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::msg_VehicleState >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg_VehicleState >*
      mutable_states();

  // repeated .msg_ControlCommand command = 2;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::msg_ControlCommand& command(int index) const;
  inline ::msg_ControlCommand* mutable_command(int index);
  inline ::msg_ControlCommand* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::msg_ControlCommand >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg_ControlCommand >*
      mutable_command();

  // @@protoc_insertion_point(class_scope:msg_MotionSample)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::msg_VehicleState > states_;
  ::google::protobuf::RepeatedPtrField< ::msg_ControlCommand > command_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_MotionSample* default_instance_;
};
// -------------------------------------------------------------------

class msg_Segments : public ::google::protobuf::Message {
 public:
  msg_Segments();
  virtual ~msg_Segments();

  msg_Segments(const msg_Segments& from);

  inline msg_Segments& operator=(const msg_Segments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_Segments& default_instance();

  void Swap(msg_Segments* other);

  // implements Message ----------------------------------------------

  msg_Segments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_Segments& from);
  void MergeFrom(const msg_Segments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg_MotionSample segments = 1;
  inline int segments_size() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 1;
  inline const ::msg_MotionSample& segments(int index) const;
  inline ::msg_MotionSample* mutable_segments(int index);
  inline ::msg_MotionSample* add_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::msg_MotionSample >&
      segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg_MotionSample >*
      mutable_segments();

  // @@protoc_insertion_point(class_scope:msg_Segments)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::msg_MotionSample > segments_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_Segments* default_instance_;
};
// -------------------------------------------------------------------

class msg_ControlPlan : public ::google::protobuf::Message {
 public:
  msg_ControlPlan();
  virtual ~msg_ControlPlan();

  msg_ControlPlan(const msg_ControlPlan& from);

  inline msg_ControlPlan& operator=(const msg_ControlPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_ControlPlan& default_instance();

  void Swap(msg_ControlPlan* other);

  // implements Message ----------------------------------------------

  msg_ControlPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_ControlPlan& from);
  void MergeFrom(const msg_ControlPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline double starttime() const;
  inline void set_starttime(double value);

  // required double endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline double endtime() const;
  inline void set_endtime(double value);

  // required .msg_MotionSample sample = 3;
  inline bool has_sample() const;
  inline void clear_sample();
  static const int kSampleFieldNumber = 3;
  inline const ::msg_MotionSample& sample() const;
  inline ::msg_MotionSample* mutable_sample();
  inline ::msg_MotionSample* release_sample();
  inline void set_allocated_sample(::msg_MotionSample* sample);

  // required .msg_VehicleState startState = 4;
  inline bool has_startstate() const;
  inline void clear_startstate();
  static const int kStartStateFieldNumber = 4;
  inline const ::msg_VehicleState& startstate() const;
  inline ::msg_VehicleState* mutable_startstate();
  inline ::msg_VehicleState* release_startstate();
  inline void set_allocated_startstate(::msg_VehicleState* startstate);

  // required .msg_VehicleState endState = 5;
  inline bool has_endstate() const;
  inline void clear_endstate();
  static const int kEndStateFieldNumber = 5;
  inline const ::msg_VehicleState& endstate() const;
  inline ::msg_VehicleState* mutable_endstate();
  inline ::msg_VehicleState* release_endstate();
  inline void set_allocated_endstate(::msg_VehicleState* endstate);

  // required int32 startSampleIndex = 6;
  inline bool has_startsampleindex() const;
  inline void clear_startsampleindex();
  static const int kStartSampleIndexFieldNumber = 6;
  inline ::google::protobuf::int32 startsampleindex() const;
  inline void set_startsampleindex(::google::protobuf::int32 value);

  // required int32 startSegmentIndex = 7;
  inline bool has_startsegmentindex() const;
  inline void clear_startsegmentindex();
  static const int kStartSegmentIndexFieldNumber = 7;
  inline ::google::protobuf::int32 startsegmentindex() const;
  inline void set_startsegmentindex(::google::protobuf::int32 value);

  // required int32 endSampleIndex = 8;
  inline bool has_endsampleindex() const;
  inline void clear_endsampleindex();
  static const int kEndSampleIndexFieldNumber = 8;
  inline ::google::protobuf::int32 endsampleindex() const;
  inline void set_endsampleindex(::google::protobuf::int32 value);

  // required int32 endSegmentIndex = 9;
  inline bool has_endsegmentindex() const;
  inline void clear_endsegmentindex();
  static const int kEndSegmentIndexFieldNumber = 9;
  inline ::google::protobuf::int32 endsegmentindex() const;
  inline void set_endsegmentindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg_ControlPlan)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_sample();
  inline void clear_has_sample();
  inline void set_has_startstate();
  inline void clear_has_startstate();
  inline void set_has_endstate();
  inline void clear_has_endstate();
  inline void set_has_startsampleindex();
  inline void clear_has_startsampleindex();
  inline void set_has_startsegmentindex();
  inline void clear_has_startsegmentindex();
  inline void set_has_endsampleindex();
  inline void clear_has_endsampleindex();
  inline void set_has_endsegmentindex();
  inline void clear_has_endsegmentindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double starttime_;
  double endtime_;
  ::msg_MotionSample* sample_;
  ::msg_VehicleState* startstate_;
  ::msg_VehicleState* endstate_;
  ::google::protobuf::int32 startsampleindex_;
  ::google::protobuf::int32 startsegmentindex_;
  ::google::protobuf::int32 endsampleindex_;
  ::google::protobuf::int32 endsegmentindex_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_ControlPlan* default_instance_;
};
// -------------------------------------------------------------------

class msg_ImuLog : public ::google::protobuf::Message {
 public:
  msg_ImuLog();
  virtual ~msg_ImuLog();

  msg_ImuLog(const msg_ImuLog& from);

  inline msg_ImuLog& operator=(const msg_ImuLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_ImuLog& default_instance();

  void Swap(msg_ImuLog* other);

  // implements Message ----------------------------------------------

  msg_ImuLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_ImuLog& from);
  void MergeFrom(const msg_ImuLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double systemTime = 1;
  inline bool has_systemtime() const;
  inline void clear_systemtime();
  static const int kSystemTimeFieldNumber = 1;
  inline double systemtime() const;
  inline void set_systemtime(double value);

  // required double deviceTime = 2;
  inline bool has_devicetime() const;
  inline void clear_devicetime();
  static const int kDeviceTimeFieldNumber = 2;
  inline double devicetime() const;
  inline void set_devicetime(double value);

  // required .msg_Matrix accel = 3;
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 3;
  inline const ::msg_Matrix& accel() const;
  inline ::msg_Matrix* mutable_accel();
  inline ::msg_Matrix* release_accel();
  inline void set_allocated_accel(::msg_Matrix* accel);

  // required .msg_Matrix gyro = 4;
  inline bool has_gyro() const;
  inline void clear_gyro();
  static const int kGyroFieldNumber = 4;
  inline const ::msg_Matrix& gyro() const;
  inline ::msg_Matrix* mutable_gyro();
  inline ::msg_Matrix* release_gyro();
  inline void set_allocated_gyro(::msg_Matrix* gyro);

  // @@protoc_insertion_point(class_scope:msg_ImuLog)
 private:
  inline void set_has_systemtime();
  inline void clear_has_systemtime();
  inline void set_has_devicetime();
  inline void clear_has_devicetime();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_gyro();
  inline void clear_has_gyro();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double systemtime_;
  double devicetime_;
  ::msg_Matrix* accel_;
  ::msg_Matrix* gyro_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_ImuLog* default_instance_;
};
// -------------------------------------------------------------------

class msg_LocalizerLog : public ::google::protobuf::Message {
 public:
  msg_LocalizerLog();
  virtual ~msg_LocalizerLog();

  msg_LocalizerLog(const msg_LocalizerLog& from);

  inline msg_LocalizerLog& operator=(const msg_LocalizerLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_LocalizerLog& default_instance();

  void Swap(msg_LocalizerLog* other);

  // implements Message ----------------------------------------------

  msg_LocalizerLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_LocalizerLog& from);
  void MergeFrom(const msg_LocalizerLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double systemTime = 1;
  inline bool has_systemtime() const;
  inline void clear_systemtime();
  static const int kSystemTimeFieldNumber = 1;
  inline double systemtime() const;
  inline void set_systemtime(double value);

  // required double deviceTime = 2;
  inline bool has_devicetime() const;
  inline void clear_devicetime();
  static const int kDeviceTimeFieldNumber = 2;
  inline double devicetime() const;
  inline void set_devicetime(double value);

  // required .msg_Matrix pose_7d = 3;
  inline bool has_pose_7d() const;
  inline void clear_pose_7d();
  static const int kPose7DFieldNumber = 3;
  inline const ::msg_Matrix& pose_7d() const;
  inline ::msg_Matrix* mutable_pose_7d();
  inline ::msg_Matrix* release_pose_7d();
  inline void set_allocated_pose_7d(::msg_Matrix* pose_7d);

  // @@protoc_insertion_point(class_scope:msg_LocalizerLog)
 private:
  inline void set_has_systemtime();
  inline void clear_has_systemtime();
  inline void set_has_devicetime();
  inline void clear_has_devicetime();
  inline void set_has_pose_7d();
  inline void clear_has_pose_7d();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double systemtime_;
  double devicetime_;
  ::msg_Matrix* pose_7d_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_LocalizerLog* default_instance_;
};
// -------------------------------------------------------------------

class msg_Log : public ::google::protobuf::Message {
 public:
  msg_Log();
  virtual ~msg_Log();

  msg_Log(const msg_Log& from);

  inline msg_Log& operator=(const msg_Log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_Log& default_instance();

  void Swap(msg_Log* other);

  // implements Message ----------------------------------------------

  msg_Log* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_Log& from);
  void MergeFrom(const msg_Log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional .msg_VehicleState vehicleState = 2;
  inline bool has_vehiclestate() const;
  inline void clear_vehiclestate();
  static const int kVehicleStateFieldNumber = 2;
  inline const ::msg_VehicleState& vehiclestate() const;
  inline ::msg_VehicleState* mutable_vehiclestate();
  inline ::msg_VehicleState* release_vehiclestate();
  inline void set_allocated_vehiclestate(::msg_VehicleState* vehiclestate);

  // optional .msg_ControlCommand controlCommand = 3;
  inline bool has_controlcommand() const;
  inline void clear_controlcommand();
  static const int kControlCommandFieldNumber = 3;
  inline const ::msg_ControlCommand& controlcommand() const;
  inline ::msg_ControlCommand* mutable_controlcommand();
  inline ::msg_ControlCommand* release_controlcommand();
  inline void set_allocated_controlcommand(::msg_ControlCommand* controlcommand);

  // optional .msg_ControlPlan controlPlan = 4;
  inline bool has_controlplan() const;
  inline void clear_controlplan();
  static const int kControlPlanFieldNumber = 4;
  inline const ::msg_ControlPlan& controlplan() const;
  inline ::msg_ControlPlan* mutable_controlplan();
  inline ::msg_ControlPlan* release_controlplan();
  inline void set_allocated_controlplan(::msg_ControlPlan* controlplan);

  // optional .msg_Segments segments = 5;
  inline bool has_segments() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 5;
  inline const ::msg_Segments& segments() const;
  inline ::msg_Segments* mutable_segments();
  inline ::msg_Segments* release_segments();
  inline void set_allocated_segments(::msg_Segments* segments);

  // optional .msg_ImuLog imu = 6;
  inline bool has_imu() const;
  inline void clear_imu();
  static const int kImuFieldNumber = 6;
  inline const ::msg_ImuLog& imu() const;
  inline ::msg_ImuLog* mutable_imu();
  inline ::msg_ImuLog* release_imu();
  inline void set_allocated_imu(::msg_ImuLog* imu);

  // optional .msg_LocalizerLog localizer = 7;
  inline bool has_localizer() const;
  inline void clear_localizer();
  static const int kLocalizerFieldNumber = 7;
  inline const ::msg_LocalizerLog& localizer() const;
  inline ::msg_LocalizerLog* mutable_localizer();
  inline ::msg_LocalizerLog* release_localizer();
  inline void set_allocated_localizer(::msg_LocalizerLog* localizer);

  // @@protoc_insertion_point(class_scope:msg_Log)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_vehiclestate();
  inline void clear_has_vehiclestate();
  inline void set_has_controlcommand();
  inline void clear_has_controlcommand();
  inline void set_has_controlplan();
  inline void clear_has_controlplan();
  inline void set_has_segments();
  inline void clear_has_segments();
  inline void set_has_imu();
  inline void clear_has_imu();
  inline void set_has_localizer();
  inline void clear_has_localizer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double timestamp_;
  ::msg_VehicleState* vehiclestate_;
  ::msg_ControlCommand* controlcommand_;
  ::msg_ControlPlan* controlplan_;
  ::msg_Segments* segments_;
  ::msg_ImuLog* imu_;
  ::msg_LocalizerLog* localizer_;
  friend void  protobuf_AddDesc_CarMessages_2eproto();
  friend void protobuf_AssignDesc_CarMessages_2eproto();
  friend void protobuf_ShutdownFile_CarMessages_2eproto();

  void InitAsDefaultInstance();
  static msg_Log* default_instance_;
};
// ===================================================================


// ===================================================================

// Imu_Accel_Gyro

// required double AccelX = 1;
inline bool Imu_Accel_Gyro::has_accelx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Imu_Accel_Gyro::set_has_accelx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Imu_Accel_Gyro::clear_has_accelx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Imu_Accel_Gyro::clear_accelx() {
  accelx_ = 0;
  clear_has_accelx();
}
inline double Imu_Accel_Gyro::accelx() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.AccelX)
  return accelx_;
}
inline void Imu_Accel_Gyro::set_accelx(double value) {
  set_has_accelx();
  accelx_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.AccelX)
}

// required double AccelY = 2;
inline bool Imu_Accel_Gyro::has_accely() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Imu_Accel_Gyro::set_has_accely() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Imu_Accel_Gyro::clear_has_accely() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Imu_Accel_Gyro::clear_accely() {
  accely_ = 0;
  clear_has_accely();
}
inline double Imu_Accel_Gyro::accely() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.AccelY)
  return accely_;
}
inline void Imu_Accel_Gyro::set_accely(double value) {
  set_has_accely();
  accely_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.AccelY)
}

// required double AccelZ = 3;
inline bool Imu_Accel_Gyro::has_accelz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Imu_Accel_Gyro::set_has_accelz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Imu_Accel_Gyro::clear_has_accelz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Imu_Accel_Gyro::clear_accelz() {
  accelz_ = 0;
  clear_has_accelz();
}
inline double Imu_Accel_Gyro::accelz() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.AccelZ)
  return accelz_;
}
inline void Imu_Accel_Gyro::set_accelz(double value) {
  set_has_accelz();
  accelz_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.AccelZ)
}

// required double GyroX = 4;
inline bool Imu_Accel_Gyro::has_gyrox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Imu_Accel_Gyro::set_has_gyrox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Imu_Accel_Gyro::clear_has_gyrox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Imu_Accel_Gyro::clear_gyrox() {
  gyrox_ = 0;
  clear_has_gyrox();
}
inline double Imu_Accel_Gyro::gyrox() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.GyroX)
  return gyrox_;
}
inline void Imu_Accel_Gyro::set_gyrox(double value) {
  set_has_gyrox();
  gyrox_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.GyroX)
}

// required double GyroY = 5;
inline bool Imu_Accel_Gyro::has_gyroy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Imu_Accel_Gyro::set_has_gyroy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Imu_Accel_Gyro::clear_has_gyroy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Imu_Accel_Gyro::clear_gyroy() {
  gyroy_ = 0;
  clear_has_gyroy();
}
inline double Imu_Accel_Gyro::gyroy() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.GyroY)
  return gyroy_;
}
inline void Imu_Accel_Gyro::set_gyroy(double value) {
  set_has_gyroy();
  gyroy_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.GyroY)
}

// required double GyroZ = 6;
inline bool Imu_Accel_Gyro::has_gyroz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Imu_Accel_Gyro::set_has_gyroz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Imu_Accel_Gyro::clear_has_gyroz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Imu_Accel_Gyro::clear_gyroz() {
  gyroz_ = 0;
  clear_has_gyroz();
}
inline double Imu_Accel_Gyro::gyroz() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.GyroZ)
  return gyroz_;
}
inline void Imu_Accel_Gyro::set_gyroz(double value) {
  set_has_gyroz();
  gyroz_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.GyroZ)
}

// required int32 timer = 7;
inline bool Imu_Accel_Gyro::has_timer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Imu_Accel_Gyro::set_has_timer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Imu_Accel_Gyro::clear_has_timer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Imu_Accel_Gyro::clear_timer() {
  timer_ = 0;
  clear_has_timer();
}
inline ::google::protobuf::int32 Imu_Accel_Gyro::timer() const {
  // @@protoc_insertion_point(field_get:Imu_Accel_Gyro.timer)
  return timer_;
}
inline void Imu_Accel_Gyro::set_timer(::google::protobuf::int32 value) {
  set_has_timer();
  timer_ = value;
  // @@protoc_insertion_point(field_set:Imu_Accel_Gyro.timer)
}

// -------------------------------------------------------------------

// CommandMsg

// required double Accel = 1;
inline bool CommandMsg::has_accel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMsg::set_has_accel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMsg::clear_has_accel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMsg::clear_accel() {
  accel_ = 0;
  clear_has_accel();
}
inline double CommandMsg::accel() const {
  // @@protoc_insertion_point(field_get:CommandMsg.Accel)
  return accel_;
}
inline void CommandMsg::set_accel(double value) {
  set_has_accel();
  accel_ = value;
  // @@protoc_insertion_point(field_set:CommandMsg.Accel)
}

// required double Phi = 2;
inline bool CommandMsg::has_phi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMsg::set_has_phi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMsg::clear_has_phi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMsg::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double CommandMsg::phi() const {
  // @@protoc_insertion_point(field_get:CommandMsg.Phi)
  return phi_;
}
inline void CommandMsg::set_phi(double value) {
  set_has_phi();
  phi_ = value;
  // @@protoc_insertion_point(field_set:CommandMsg.Phi)
}

// -------------------------------------------------------------------

// CommandReply

// -------------------------------------------------------------------

// msg_Matrix

// required uint32 rows = 1;
inline bool msg_Matrix::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_Matrix::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_Matrix::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_Matrix::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 msg_Matrix::rows() const {
  // @@protoc_insertion_point(field_get:msg_Matrix.rows)
  return rows_;
}
inline void msg_Matrix::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:msg_Matrix.rows)
}

// required uint32 cols = 2;
inline bool msg_Matrix::has_cols() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_Matrix::set_has_cols() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_Matrix::clear_has_cols() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_Matrix::clear_cols() {
  cols_ = 0u;
  clear_has_cols();
}
inline ::google::protobuf::uint32 msg_Matrix::cols() const {
  // @@protoc_insertion_point(field_get:msg_Matrix.cols)
  return cols_;
}
inline void msg_Matrix::set_cols(::google::protobuf::uint32 value) {
  set_has_cols();
  cols_ = value;
  // @@protoc_insertion_point(field_set:msg_Matrix.cols)
}

// repeated double data = 3 [packed = true];
inline int msg_Matrix::data_size() const {
  return data_.size();
}
inline void msg_Matrix::clear_data() {
  data_.Clear();
}
inline double msg_Matrix::data(int index) const {
  // @@protoc_insertion_point(field_get:msg_Matrix.data)
  return data_.Get(index);
}
inline void msg_Matrix::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg_Matrix.data)
}
inline void msg_Matrix::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:msg_Matrix.data)
}
inline const ::google::protobuf::RepeatedField< double >&
msg_Matrix::data() const {
  // @@protoc_insertion_point(field_list:msg_Matrix.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
msg_Matrix::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:msg_Matrix.data)
  return &data_;
}

// -------------------------------------------------------------------

// msg_ControlCommand

// required double force = 1;
inline bool msg_ControlCommand::has_force() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_ControlCommand::set_has_force() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_ControlCommand::clear_has_force() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_ControlCommand::clear_force() {
  force_ = 0;
  clear_has_force();
}
inline double msg_ControlCommand::force() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.force)
  return force_;
}
inline void msg_ControlCommand::set_force(double value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlCommand.force)
}

// required double phi = 2;
inline bool msg_ControlCommand::has_phi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_ControlCommand::set_has_phi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_ControlCommand::clear_has_phi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_ControlCommand::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double msg_ControlCommand::phi() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.phi)
  return phi_;
}
inline void msg_ControlCommand::set_phi(double value) {
  set_has_phi();
  phi_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlCommand.phi)
}

// required double curvature = 3;
inline bool msg_ControlCommand::has_curvature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_ControlCommand::set_has_curvature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_ControlCommand::clear_has_curvature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_ControlCommand::clear_curvature() {
  curvature_ = 0;
  clear_has_curvature();
}
inline double msg_ControlCommand::curvature() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.curvature)
  return curvature_;
}
inline void msg_ControlCommand::set_curvature(double value) {
  set_has_curvature();
  curvature_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlCommand.curvature)
}

// required double dt = 4;
inline bool msg_ControlCommand::has_dt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_ControlCommand::set_has_dt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_ControlCommand::clear_has_dt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_ControlCommand::clear_dt() {
  dt_ = 0;
  clear_has_dt();
}
inline double msg_ControlCommand::dt() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.dt)
  return dt_;
}
inline void msg_ControlCommand::set_dt(double value) {
  set_has_dt();
  dt_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlCommand.dt)
}

// required double time = 5;
inline bool msg_ControlCommand::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg_ControlCommand::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg_ControlCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg_ControlCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double msg_ControlCommand::time() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.time)
  return time_;
}
inline void msg_ControlCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlCommand.time)
}

// required .msg_Matrix torque_3d = 6;
inline bool msg_ControlCommand::has_torque_3d() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void msg_ControlCommand::set_has_torque_3d() {
  _has_bits_[0] |= 0x00000020u;
}
inline void msg_ControlCommand::clear_has_torque_3d() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void msg_ControlCommand::clear_torque_3d() {
  if (torque_3d_ != NULL) torque_3d_->::msg_Matrix::Clear();
  clear_has_torque_3d();
}
inline const ::msg_Matrix& msg_ControlCommand::torque_3d() const {
  // @@protoc_insertion_point(field_get:msg_ControlCommand.torque_3d)
  return torque_3d_ != NULL ? *torque_3d_ : *default_instance_->torque_3d_;
}
inline ::msg_Matrix* msg_ControlCommand::mutable_torque_3d() {
  set_has_torque_3d();
  if (torque_3d_ == NULL) torque_3d_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_ControlCommand.torque_3d)
  return torque_3d_;
}
inline ::msg_Matrix* msg_ControlCommand::release_torque_3d() {
  clear_has_torque_3d();
  ::msg_Matrix* temp = torque_3d_;
  torque_3d_ = NULL;
  return temp;
}
inline void msg_ControlCommand::set_allocated_torque_3d(::msg_Matrix* torque_3d) {
  delete torque_3d_;
  torque_3d_ = torque_3d;
  if (torque_3d) {
    set_has_torque_3d();
  } else {
    clear_has_torque_3d();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ControlCommand.torque_3d)
}

// -------------------------------------------------------------------

// msg_VehicleState

// required .msg_Matrix pose_7d = 1;
inline bool msg_VehicleState::has_pose_7d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_VehicleState::set_has_pose_7d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_VehicleState::clear_has_pose_7d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_VehicleState::clear_pose_7d() {
  if (pose_7d_ != NULL) pose_7d_->::msg_Matrix::Clear();
  clear_has_pose_7d();
}
inline const ::msg_Matrix& msg_VehicleState::pose_7d() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.pose_7d)
  return pose_7d_ != NULL ? *pose_7d_ : *default_instance_->pose_7d_;
}
inline ::msg_Matrix* msg_VehicleState::mutable_pose_7d() {
  set_has_pose_7d();
  if (pose_7d_ == NULL) pose_7d_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_VehicleState.pose_7d)
  return pose_7d_;
}
inline ::msg_Matrix* msg_VehicleState::release_pose_7d() {
  clear_has_pose_7d();
  ::msg_Matrix* temp = pose_7d_;
  pose_7d_ = NULL;
  return temp;
}
inline void msg_VehicleState::set_allocated_pose_7d(::msg_Matrix* pose_7d) {
  delete pose_7d_;
  pose_7d_ = pose_7d;
  if (pose_7d) {
    set_has_pose_7d();
  } else {
    clear_has_pose_7d();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_VehicleState.pose_7d)
}

// required .msg_Matrix vel_3d = 2;
inline bool msg_VehicleState::has_vel_3d() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_VehicleState::set_has_vel_3d() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_VehicleState::clear_has_vel_3d() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_VehicleState::clear_vel_3d() {
  if (vel_3d_ != NULL) vel_3d_->::msg_Matrix::Clear();
  clear_has_vel_3d();
}
inline const ::msg_Matrix& msg_VehicleState::vel_3d() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.vel_3d)
  return vel_3d_ != NULL ? *vel_3d_ : *default_instance_->vel_3d_;
}
inline ::msg_Matrix* msg_VehicleState::mutable_vel_3d() {
  set_has_vel_3d();
  if (vel_3d_ == NULL) vel_3d_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_VehicleState.vel_3d)
  return vel_3d_;
}
inline ::msg_Matrix* msg_VehicleState::release_vel_3d() {
  clear_has_vel_3d();
  ::msg_Matrix* temp = vel_3d_;
  vel_3d_ = NULL;
  return temp;
}
inline void msg_VehicleState::set_allocated_vel_3d(::msg_Matrix* vel_3d) {
  delete vel_3d_;
  vel_3d_ = vel_3d;
  if (vel_3d) {
    set_has_vel_3d();
  } else {
    clear_has_vel_3d();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_VehicleState.vel_3d)
}

// required .msg_Matrix w_3d = 3;
inline bool msg_VehicleState::has_w_3d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_VehicleState::set_has_w_3d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_VehicleState::clear_has_w_3d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_VehicleState::clear_w_3d() {
  if (w_3d_ != NULL) w_3d_->::msg_Matrix::Clear();
  clear_has_w_3d();
}
inline const ::msg_Matrix& msg_VehicleState::w_3d() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.w_3d)
  return w_3d_ != NULL ? *w_3d_ : *default_instance_->w_3d_;
}
inline ::msg_Matrix* msg_VehicleState::mutable_w_3d() {
  set_has_w_3d();
  if (w_3d_ == NULL) w_3d_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_VehicleState.w_3d)
  return w_3d_;
}
inline ::msg_Matrix* msg_VehicleState::release_w_3d() {
  clear_has_w_3d();
  ::msg_Matrix* temp = w_3d_;
  w_3d_ = NULL;
  return temp;
}
inline void msg_VehicleState::set_allocated_w_3d(::msg_Matrix* w_3d) {
  delete w_3d_;
  w_3d_ = w_3d;
  if (w_3d) {
    set_has_w_3d();
  } else {
    clear_has_w_3d();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_VehicleState.w_3d)
}

// required double curvature = 4;
inline bool msg_VehicleState::has_curvature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_VehicleState::set_has_curvature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_VehicleState::clear_has_curvature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_VehicleState::clear_curvature() {
  curvature_ = 0;
  clear_has_curvature();
}
inline double msg_VehicleState::curvature() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.curvature)
  return curvature_;
}
inline void msg_VehicleState::set_curvature(double value) {
  set_has_curvature();
  curvature_ = value;
  // @@protoc_insertion_point(field_set:msg_VehicleState.curvature)
}

// required double steering = 5;
inline bool msg_VehicleState::has_steering() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg_VehicleState::set_has_steering() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg_VehicleState::clear_has_steering() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg_VehicleState::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
inline double msg_VehicleState::steering() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.steering)
  return steering_;
}
inline void msg_VehicleState::set_steering(double value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:msg_VehicleState.steering)
}

// required double time = 6;
inline bool msg_VehicleState::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void msg_VehicleState::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void msg_VehicleState::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void msg_VehicleState::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double msg_VehicleState::time() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.time)
  return time_;
}
inline void msg_VehicleState::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:msg_VehicleState.time)
}

// required int32 source = 7;
inline bool msg_VehicleState::has_source() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void msg_VehicleState::set_has_source() {
  _has_bits_[0] |= 0x00000040u;
}
inline void msg_VehicleState::clear_has_source() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void msg_VehicleState::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 msg_VehicleState::source() const {
  // @@protoc_insertion_point(field_get:msg_VehicleState.source)
  return source_;
}
inline void msg_VehicleState::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:msg_VehicleState.source)
}

// -------------------------------------------------------------------

// msg_MotionSample

// repeated .msg_VehicleState states = 1;
inline int msg_MotionSample::states_size() const {
  return states_.size();
}
inline void msg_MotionSample::clear_states() {
  states_.Clear();
}
inline const ::msg_VehicleState& msg_MotionSample::states(int index) const {
  // @@protoc_insertion_point(field_get:msg_MotionSample.states)
  return states_.Get(index);
}
inline ::msg_VehicleState* msg_MotionSample::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:msg_MotionSample.states)
  return states_.Mutable(index);
}
inline ::msg_VehicleState* msg_MotionSample::add_states() {
  // @@protoc_insertion_point(field_add:msg_MotionSample.states)
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg_VehicleState >&
msg_MotionSample::states() const {
  // @@protoc_insertion_point(field_list:msg_MotionSample.states)
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg_VehicleState >*
msg_MotionSample::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:msg_MotionSample.states)
  return &states_;
}

// repeated .msg_ControlCommand command = 2;
inline int msg_MotionSample::command_size() const {
  return command_.size();
}
inline void msg_MotionSample::clear_command() {
  command_.Clear();
}
inline const ::msg_ControlCommand& msg_MotionSample::command(int index) const {
  // @@protoc_insertion_point(field_get:msg_MotionSample.command)
  return command_.Get(index);
}
inline ::msg_ControlCommand* msg_MotionSample::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:msg_MotionSample.command)
  return command_.Mutable(index);
}
inline ::msg_ControlCommand* msg_MotionSample::add_command() {
  // @@protoc_insertion_point(field_add:msg_MotionSample.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg_ControlCommand >&
msg_MotionSample::command() const {
  // @@protoc_insertion_point(field_list:msg_MotionSample.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg_ControlCommand >*
msg_MotionSample::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:msg_MotionSample.command)
  return &command_;
}

// -------------------------------------------------------------------

// msg_Segments

// repeated .msg_MotionSample segments = 1;
inline int msg_Segments::segments_size() const {
  return segments_.size();
}
inline void msg_Segments::clear_segments() {
  segments_.Clear();
}
inline const ::msg_MotionSample& msg_Segments::segments(int index) const {
  // @@protoc_insertion_point(field_get:msg_Segments.segments)
  return segments_.Get(index);
}
inline ::msg_MotionSample* msg_Segments::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:msg_Segments.segments)
  return segments_.Mutable(index);
}
inline ::msg_MotionSample* msg_Segments::add_segments() {
  // @@protoc_insertion_point(field_add:msg_Segments.segments)
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg_MotionSample >&
msg_Segments::segments() const {
  // @@protoc_insertion_point(field_list:msg_Segments.segments)
  return segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg_MotionSample >*
msg_Segments::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:msg_Segments.segments)
  return &segments_;
}

// -------------------------------------------------------------------

// msg_ControlPlan

// required double startTime = 1;
inline bool msg_ControlPlan::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_ControlPlan::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_ControlPlan::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_ControlPlan::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline double msg_ControlPlan::starttime() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.startTime)
  return starttime_;
}
inline void msg_ControlPlan::set_starttime(double value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.startTime)
}

// required double endTime = 2;
inline bool msg_ControlPlan::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_ControlPlan::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_ControlPlan::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_ControlPlan::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline double msg_ControlPlan::endtime() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.endTime)
  return endtime_;
}
inline void msg_ControlPlan::set_endtime(double value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.endTime)
}

// required .msg_MotionSample sample = 3;
inline bool msg_ControlPlan::has_sample() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_ControlPlan::set_has_sample() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_ControlPlan::clear_has_sample() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_ControlPlan::clear_sample() {
  if (sample_ != NULL) sample_->::msg_MotionSample::Clear();
  clear_has_sample();
}
inline const ::msg_MotionSample& msg_ControlPlan::sample() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.sample)
  return sample_ != NULL ? *sample_ : *default_instance_->sample_;
}
inline ::msg_MotionSample* msg_ControlPlan::mutable_sample() {
  set_has_sample();
  if (sample_ == NULL) sample_ = new ::msg_MotionSample;
  // @@protoc_insertion_point(field_mutable:msg_ControlPlan.sample)
  return sample_;
}
inline ::msg_MotionSample* msg_ControlPlan::release_sample() {
  clear_has_sample();
  ::msg_MotionSample* temp = sample_;
  sample_ = NULL;
  return temp;
}
inline void msg_ControlPlan::set_allocated_sample(::msg_MotionSample* sample) {
  delete sample_;
  sample_ = sample;
  if (sample) {
    set_has_sample();
  } else {
    clear_has_sample();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ControlPlan.sample)
}

// required .msg_VehicleState startState = 4;
inline bool msg_ControlPlan::has_startstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_ControlPlan::set_has_startstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_ControlPlan::clear_has_startstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_ControlPlan::clear_startstate() {
  if (startstate_ != NULL) startstate_->::msg_VehicleState::Clear();
  clear_has_startstate();
}
inline const ::msg_VehicleState& msg_ControlPlan::startstate() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.startState)
  return startstate_ != NULL ? *startstate_ : *default_instance_->startstate_;
}
inline ::msg_VehicleState* msg_ControlPlan::mutable_startstate() {
  set_has_startstate();
  if (startstate_ == NULL) startstate_ = new ::msg_VehicleState;
  // @@protoc_insertion_point(field_mutable:msg_ControlPlan.startState)
  return startstate_;
}
inline ::msg_VehicleState* msg_ControlPlan::release_startstate() {
  clear_has_startstate();
  ::msg_VehicleState* temp = startstate_;
  startstate_ = NULL;
  return temp;
}
inline void msg_ControlPlan::set_allocated_startstate(::msg_VehicleState* startstate) {
  delete startstate_;
  startstate_ = startstate;
  if (startstate) {
    set_has_startstate();
  } else {
    clear_has_startstate();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ControlPlan.startState)
}

// required .msg_VehicleState endState = 5;
inline bool msg_ControlPlan::has_endstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg_ControlPlan::set_has_endstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg_ControlPlan::clear_has_endstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg_ControlPlan::clear_endstate() {
  if (endstate_ != NULL) endstate_->::msg_VehicleState::Clear();
  clear_has_endstate();
}
inline const ::msg_VehicleState& msg_ControlPlan::endstate() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.endState)
  return endstate_ != NULL ? *endstate_ : *default_instance_->endstate_;
}
inline ::msg_VehicleState* msg_ControlPlan::mutable_endstate() {
  set_has_endstate();
  if (endstate_ == NULL) endstate_ = new ::msg_VehicleState;
  // @@protoc_insertion_point(field_mutable:msg_ControlPlan.endState)
  return endstate_;
}
inline ::msg_VehicleState* msg_ControlPlan::release_endstate() {
  clear_has_endstate();
  ::msg_VehicleState* temp = endstate_;
  endstate_ = NULL;
  return temp;
}
inline void msg_ControlPlan::set_allocated_endstate(::msg_VehicleState* endstate) {
  delete endstate_;
  endstate_ = endstate;
  if (endstate) {
    set_has_endstate();
  } else {
    clear_has_endstate();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ControlPlan.endState)
}

// required int32 startSampleIndex = 6;
inline bool msg_ControlPlan::has_startsampleindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void msg_ControlPlan::set_has_startsampleindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void msg_ControlPlan::clear_has_startsampleindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void msg_ControlPlan::clear_startsampleindex() {
  startsampleindex_ = 0;
  clear_has_startsampleindex();
}
inline ::google::protobuf::int32 msg_ControlPlan::startsampleindex() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.startSampleIndex)
  return startsampleindex_;
}
inline void msg_ControlPlan::set_startsampleindex(::google::protobuf::int32 value) {
  set_has_startsampleindex();
  startsampleindex_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.startSampleIndex)
}

// required int32 startSegmentIndex = 7;
inline bool msg_ControlPlan::has_startsegmentindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void msg_ControlPlan::set_has_startsegmentindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void msg_ControlPlan::clear_has_startsegmentindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void msg_ControlPlan::clear_startsegmentindex() {
  startsegmentindex_ = 0;
  clear_has_startsegmentindex();
}
inline ::google::protobuf::int32 msg_ControlPlan::startsegmentindex() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.startSegmentIndex)
  return startsegmentindex_;
}
inline void msg_ControlPlan::set_startsegmentindex(::google::protobuf::int32 value) {
  set_has_startsegmentindex();
  startsegmentindex_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.startSegmentIndex)
}

// required int32 endSampleIndex = 8;
inline bool msg_ControlPlan::has_endsampleindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void msg_ControlPlan::set_has_endsampleindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void msg_ControlPlan::clear_has_endsampleindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void msg_ControlPlan::clear_endsampleindex() {
  endsampleindex_ = 0;
  clear_has_endsampleindex();
}
inline ::google::protobuf::int32 msg_ControlPlan::endsampleindex() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.endSampleIndex)
  return endsampleindex_;
}
inline void msg_ControlPlan::set_endsampleindex(::google::protobuf::int32 value) {
  set_has_endsampleindex();
  endsampleindex_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.endSampleIndex)
}

// required int32 endSegmentIndex = 9;
inline bool msg_ControlPlan::has_endsegmentindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void msg_ControlPlan::set_has_endsegmentindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void msg_ControlPlan::clear_has_endsegmentindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void msg_ControlPlan::clear_endsegmentindex() {
  endsegmentindex_ = 0;
  clear_has_endsegmentindex();
}
inline ::google::protobuf::int32 msg_ControlPlan::endsegmentindex() const {
  // @@protoc_insertion_point(field_get:msg_ControlPlan.endSegmentIndex)
  return endsegmentindex_;
}
inline void msg_ControlPlan::set_endsegmentindex(::google::protobuf::int32 value) {
  set_has_endsegmentindex();
  endsegmentindex_ = value;
  // @@protoc_insertion_point(field_set:msg_ControlPlan.endSegmentIndex)
}

// -------------------------------------------------------------------

// msg_ImuLog

// required double systemTime = 1;
inline bool msg_ImuLog::has_systemtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_ImuLog::set_has_systemtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_ImuLog::clear_has_systemtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_ImuLog::clear_systemtime() {
  systemtime_ = 0;
  clear_has_systemtime();
}
inline double msg_ImuLog::systemtime() const {
  // @@protoc_insertion_point(field_get:msg_ImuLog.systemTime)
  return systemtime_;
}
inline void msg_ImuLog::set_systemtime(double value) {
  set_has_systemtime();
  systemtime_ = value;
  // @@protoc_insertion_point(field_set:msg_ImuLog.systemTime)
}

// required double deviceTime = 2;
inline bool msg_ImuLog::has_devicetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_ImuLog::set_has_devicetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_ImuLog::clear_has_devicetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_ImuLog::clear_devicetime() {
  devicetime_ = 0;
  clear_has_devicetime();
}
inline double msg_ImuLog::devicetime() const {
  // @@protoc_insertion_point(field_get:msg_ImuLog.deviceTime)
  return devicetime_;
}
inline void msg_ImuLog::set_devicetime(double value) {
  set_has_devicetime();
  devicetime_ = value;
  // @@protoc_insertion_point(field_set:msg_ImuLog.deviceTime)
}

// required .msg_Matrix accel = 3;
inline bool msg_ImuLog::has_accel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_ImuLog::set_has_accel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_ImuLog::clear_has_accel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_ImuLog::clear_accel() {
  if (accel_ != NULL) accel_->::msg_Matrix::Clear();
  clear_has_accel();
}
inline const ::msg_Matrix& msg_ImuLog::accel() const {
  // @@protoc_insertion_point(field_get:msg_ImuLog.accel)
  return accel_ != NULL ? *accel_ : *default_instance_->accel_;
}
inline ::msg_Matrix* msg_ImuLog::mutable_accel() {
  set_has_accel();
  if (accel_ == NULL) accel_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_ImuLog.accel)
  return accel_;
}
inline ::msg_Matrix* msg_ImuLog::release_accel() {
  clear_has_accel();
  ::msg_Matrix* temp = accel_;
  accel_ = NULL;
  return temp;
}
inline void msg_ImuLog::set_allocated_accel(::msg_Matrix* accel) {
  delete accel_;
  accel_ = accel;
  if (accel) {
    set_has_accel();
  } else {
    clear_has_accel();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ImuLog.accel)
}

// required .msg_Matrix gyro = 4;
inline bool msg_ImuLog::has_gyro() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_ImuLog::set_has_gyro() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_ImuLog::clear_has_gyro() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_ImuLog::clear_gyro() {
  if (gyro_ != NULL) gyro_->::msg_Matrix::Clear();
  clear_has_gyro();
}
inline const ::msg_Matrix& msg_ImuLog::gyro() const {
  // @@protoc_insertion_point(field_get:msg_ImuLog.gyro)
  return gyro_ != NULL ? *gyro_ : *default_instance_->gyro_;
}
inline ::msg_Matrix* msg_ImuLog::mutable_gyro() {
  set_has_gyro();
  if (gyro_ == NULL) gyro_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_ImuLog.gyro)
  return gyro_;
}
inline ::msg_Matrix* msg_ImuLog::release_gyro() {
  clear_has_gyro();
  ::msg_Matrix* temp = gyro_;
  gyro_ = NULL;
  return temp;
}
inline void msg_ImuLog::set_allocated_gyro(::msg_Matrix* gyro) {
  delete gyro_;
  gyro_ = gyro;
  if (gyro) {
    set_has_gyro();
  } else {
    clear_has_gyro();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_ImuLog.gyro)
}

// -------------------------------------------------------------------

// msg_LocalizerLog

// required double systemTime = 1;
inline bool msg_LocalizerLog::has_systemtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_LocalizerLog::set_has_systemtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_LocalizerLog::clear_has_systemtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_LocalizerLog::clear_systemtime() {
  systemtime_ = 0;
  clear_has_systemtime();
}
inline double msg_LocalizerLog::systemtime() const {
  // @@protoc_insertion_point(field_get:msg_LocalizerLog.systemTime)
  return systemtime_;
}
inline void msg_LocalizerLog::set_systemtime(double value) {
  set_has_systemtime();
  systemtime_ = value;
  // @@protoc_insertion_point(field_set:msg_LocalizerLog.systemTime)
}

// required double deviceTime = 2;
inline bool msg_LocalizerLog::has_devicetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_LocalizerLog::set_has_devicetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_LocalizerLog::clear_has_devicetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_LocalizerLog::clear_devicetime() {
  devicetime_ = 0;
  clear_has_devicetime();
}
inline double msg_LocalizerLog::devicetime() const {
  // @@protoc_insertion_point(field_get:msg_LocalizerLog.deviceTime)
  return devicetime_;
}
inline void msg_LocalizerLog::set_devicetime(double value) {
  set_has_devicetime();
  devicetime_ = value;
  // @@protoc_insertion_point(field_set:msg_LocalizerLog.deviceTime)
}

// required .msg_Matrix pose_7d = 3;
inline bool msg_LocalizerLog::has_pose_7d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_LocalizerLog::set_has_pose_7d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_LocalizerLog::clear_has_pose_7d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_LocalizerLog::clear_pose_7d() {
  if (pose_7d_ != NULL) pose_7d_->::msg_Matrix::Clear();
  clear_has_pose_7d();
}
inline const ::msg_Matrix& msg_LocalizerLog::pose_7d() const {
  // @@protoc_insertion_point(field_get:msg_LocalizerLog.pose_7d)
  return pose_7d_ != NULL ? *pose_7d_ : *default_instance_->pose_7d_;
}
inline ::msg_Matrix* msg_LocalizerLog::mutable_pose_7d() {
  set_has_pose_7d();
  if (pose_7d_ == NULL) pose_7d_ = new ::msg_Matrix;
  // @@protoc_insertion_point(field_mutable:msg_LocalizerLog.pose_7d)
  return pose_7d_;
}
inline ::msg_Matrix* msg_LocalizerLog::release_pose_7d() {
  clear_has_pose_7d();
  ::msg_Matrix* temp = pose_7d_;
  pose_7d_ = NULL;
  return temp;
}
inline void msg_LocalizerLog::set_allocated_pose_7d(::msg_Matrix* pose_7d) {
  delete pose_7d_;
  pose_7d_ = pose_7d;
  if (pose_7d) {
    set_has_pose_7d();
  } else {
    clear_has_pose_7d();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_LocalizerLog.pose_7d)
}

// -------------------------------------------------------------------

// msg_Log

// required double timestamp = 1;
inline bool msg_Log::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_Log::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_Log::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_Log::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double msg_Log::timestamp() const {
  // @@protoc_insertion_point(field_get:msg_Log.timestamp)
  return timestamp_;
}
inline void msg_Log::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:msg_Log.timestamp)
}

// optional .msg_VehicleState vehicleState = 2;
inline bool msg_Log::has_vehiclestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_Log::set_has_vehiclestate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_Log::clear_has_vehiclestate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_Log::clear_vehiclestate() {
  if (vehiclestate_ != NULL) vehiclestate_->::msg_VehicleState::Clear();
  clear_has_vehiclestate();
}
inline const ::msg_VehicleState& msg_Log::vehiclestate() const {
  // @@protoc_insertion_point(field_get:msg_Log.vehicleState)
  return vehiclestate_ != NULL ? *vehiclestate_ : *default_instance_->vehiclestate_;
}
inline ::msg_VehicleState* msg_Log::mutable_vehiclestate() {
  set_has_vehiclestate();
  if (vehiclestate_ == NULL) vehiclestate_ = new ::msg_VehicleState;
  // @@protoc_insertion_point(field_mutable:msg_Log.vehicleState)
  return vehiclestate_;
}
inline ::msg_VehicleState* msg_Log::release_vehiclestate() {
  clear_has_vehiclestate();
  ::msg_VehicleState* temp = vehiclestate_;
  vehiclestate_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_vehiclestate(::msg_VehicleState* vehiclestate) {
  delete vehiclestate_;
  vehiclestate_ = vehiclestate;
  if (vehiclestate) {
    set_has_vehiclestate();
  } else {
    clear_has_vehiclestate();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.vehicleState)
}

// optional .msg_ControlCommand controlCommand = 3;
inline bool msg_Log::has_controlcommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_Log::set_has_controlcommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_Log::clear_has_controlcommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_Log::clear_controlcommand() {
  if (controlcommand_ != NULL) controlcommand_->::msg_ControlCommand::Clear();
  clear_has_controlcommand();
}
inline const ::msg_ControlCommand& msg_Log::controlcommand() const {
  // @@protoc_insertion_point(field_get:msg_Log.controlCommand)
  return controlcommand_ != NULL ? *controlcommand_ : *default_instance_->controlcommand_;
}
inline ::msg_ControlCommand* msg_Log::mutable_controlcommand() {
  set_has_controlcommand();
  if (controlcommand_ == NULL) controlcommand_ = new ::msg_ControlCommand;
  // @@protoc_insertion_point(field_mutable:msg_Log.controlCommand)
  return controlcommand_;
}
inline ::msg_ControlCommand* msg_Log::release_controlcommand() {
  clear_has_controlcommand();
  ::msg_ControlCommand* temp = controlcommand_;
  controlcommand_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_controlcommand(::msg_ControlCommand* controlcommand) {
  delete controlcommand_;
  controlcommand_ = controlcommand;
  if (controlcommand) {
    set_has_controlcommand();
  } else {
    clear_has_controlcommand();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.controlCommand)
}

// optional .msg_ControlPlan controlPlan = 4;
inline bool msg_Log::has_controlplan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_Log::set_has_controlplan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_Log::clear_has_controlplan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_Log::clear_controlplan() {
  if (controlplan_ != NULL) controlplan_->::msg_ControlPlan::Clear();
  clear_has_controlplan();
}
inline const ::msg_ControlPlan& msg_Log::controlplan() const {
  // @@protoc_insertion_point(field_get:msg_Log.controlPlan)
  return controlplan_ != NULL ? *controlplan_ : *default_instance_->controlplan_;
}
inline ::msg_ControlPlan* msg_Log::mutable_controlplan() {
  set_has_controlplan();
  if (controlplan_ == NULL) controlplan_ = new ::msg_ControlPlan;
  // @@protoc_insertion_point(field_mutable:msg_Log.controlPlan)
  return controlplan_;
}
inline ::msg_ControlPlan* msg_Log::release_controlplan() {
  clear_has_controlplan();
  ::msg_ControlPlan* temp = controlplan_;
  controlplan_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_controlplan(::msg_ControlPlan* controlplan) {
  delete controlplan_;
  controlplan_ = controlplan;
  if (controlplan) {
    set_has_controlplan();
  } else {
    clear_has_controlplan();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.controlPlan)
}

// optional .msg_Segments segments = 5;
inline bool msg_Log::has_segments() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg_Log::set_has_segments() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg_Log::clear_has_segments() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg_Log::clear_segments() {
  if (segments_ != NULL) segments_->::msg_Segments::Clear();
  clear_has_segments();
}
inline const ::msg_Segments& msg_Log::segments() const {
  // @@protoc_insertion_point(field_get:msg_Log.segments)
  return segments_ != NULL ? *segments_ : *default_instance_->segments_;
}
inline ::msg_Segments* msg_Log::mutable_segments() {
  set_has_segments();
  if (segments_ == NULL) segments_ = new ::msg_Segments;
  // @@protoc_insertion_point(field_mutable:msg_Log.segments)
  return segments_;
}
inline ::msg_Segments* msg_Log::release_segments() {
  clear_has_segments();
  ::msg_Segments* temp = segments_;
  segments_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_segments(::msg_Segments* segments) {
  delete segments_;
  segments_ = segments;
  if (segments) {
    set_has_segments();
  } else {
    clear_has_segments();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.segments)
}

// optional .msg_ImuLog imu = 6;
inline bool msg_Log::has_imu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void msg_Log::set_has_imu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void msg_Log::clear_has_imu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void msg_Log::clear_imu() {
  if (imu_ != NULL) imu_->::msg_ImuLog::Clear();
  clear_has_imu();
}
inline const ::msg_ImuLog& msg_Log::imu() const {
  // @@protoc_insertion_point(field_get:msg_Log.imu)
  return imu_ != NULL ? *imu_ : *default_instance_->imu_;
}
inline ::msg_ImuLog* msg_Log::mutable_imu() {
  set_has_imu();
  if (imu_ == NULL) imu_ = new ::msg_ImuLog;
  // @@protoc_insertion_point(field_mutable:msg_Log.imu)
  return imu_;
}
inline ::msg_ImuLog* msg_Log::release_imu() {
  clear_has_imu();
  ::msg_ImuLog* temp = imu_;
  imu_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_imu(::msg_ImuLog* imu) {
  delete imu_;
  imu_ = imu;
  if (imu) {
    set_has_imu();
  } else {
    clear_has_imu();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.imu)
}

// optional .msg_LocalizerLog localizer = 7;
inline bool msg_Log::has_localizer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void msg_Log::set_has_localizer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void msg_Log::clear_has_localizer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void msg_Log::clear_localizer() {
  if (localizer_ != NULL) localizer_->::msg_LocalizerLog::Clear();
  clear_has_localizer();
}
inline const ::msg_LocalizerLog& msg_Log::localizer() const {
  // @@protoc_insertion_point(field_get:msg_Log.localizer)
  return localizer_ != NULL ? *localizer_ : *default_instance_->localizer_;
}
inline ::msg_LocalizerLog* msg_Log::mutable_localizer() {
  set_has_localizer();
  if (localizer_ == NULL) localizer_ = new ::msg_LocalizerLog;
  // @@protoc_insertion_point(field_mutable:msg_Log.localizer)
  return localizer_;
}
inline ::msg_LocalizerLog* msg_Log::release_localizer() {
  clear_has_localizer();
  ::msg_LocalizerLog* temp = localizer_;
  localizer_ = NULL;
  return temp;
}
inline void msg_Log::set_allocated_localizer(::msg_LocalizerLog* localizer) {
  delete localizer_;
  localizer_ = localizer;
  if (localizer) {
    set_has_localizer();
  } else {
    clear_has_localizer();
  }
  // @@protoc_insertion_point(field_set_allocated:msg_Log.localizer)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CarMessages_2eproto__INCLUDED
